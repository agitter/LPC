{
    "collab_server" : "",
    "contents" : "# takes a vector of correlation and a vector of lags, returns the best lag\n#   based on sum of highest correlation\nscore <- function(corr, lags){\n    alags <- sort(unique(lags))\n    value <- rep(NA, length(alags))\n    for(i in seq(alags)){\n        value[i] <- sum(corr[lags == alags[i]])\n    }\n    return(alags[which.max(value)])\n}\n\n#computes the weighted correlation between x and y based on the weight w\nwt.corr <- function(x, y, w){\n    stopifnot(is.vector(x), is.vector(y), is.vector(x),\n    length(x) == length(y), length(x) == length(w))\n    if(sum(w) != 1){\n        w <- w / sum(w)\n    }\n    mx <- sum(w * x)\n    my <- sum(w * y)\n    cov <- sum(w * (x - mx) * (y - my))\n    sdx <- sqrt(sum(w * (x - mx)^2))\n    sdy <- sqrt(sum(w * (y - my)^2))\n    return(cov / (sdx * sdy))\n}\n\n#computes mean difference squared between x1 and x2\nmeansq.dist <- function(x1, x2) {mean((x1 - x2) ^ 2)}\n\n#returns possible values of C based on timepoints and max lag\nfindC <- function(timepoints, max.lag = NULL, pi = 0.95, iter = 10){\n    stopifnot(is.vector(timepoints), max.lag <= length(timepoints) / 4, is.numeric(max.lag))\n    penalty <- seq(0.5, 0.95, length.out = iter)\n    vals <- NULL\n    for(i in 1:max.lag){\n        vals <- c(vals, meansq.dist(timepoints[(i + 1):length(timepoints)],\n        timepoints[1:(length(timepoints) - i)]))\n    }\n    vals <- - mean(vals) / log(penalty)\n    return(vals)\n}\n\n#returns the best possible lags for each row in the dataset after considering max.lag\nbest.lag <- function(data, max.lag = NULL, timepoints, C){\n  if(is.null(max.lag)){\n    max.lag <- floor(length(timepoints) / 4)\n  }\n  stopifnot(dim(data)[2] == length(timepoints), max.lag <= length(timepoints) / 4)\n  shift <- rep(NA, dim(data)[1])\n  for(i in 1:dim(data)[1]){\n        lags <- rep(NA, (dim(data)[1]))\n        bcorr <- rep(NA, (dim(data)[1]))\n        for(j in 1:dim(data)[1]){\n            if(i != j){\n                corr <- rep(NA, max.lag * 2 + 1)\n                for(k in max.lag:1){\n                    weight <- rbind(timepoints[(k + 1):length(timepoints)],\n                    timepoints[1:(length(timepoints) - k)])\n                    weight <- exp(-1/C * apply(weight, 2, function(x){(diff(x))^2}))\n                    corr[max.lag - k + 1] <- exp(-1/C * meansq.dist(timepoints[(k + 1):length(timepoints)],\n                    timepoints[1:(length(timepoints) - k)])) *\n                    wt.corr(data[i, 1:(length(timepoints) - k)],\n                    data[j, (k + 1):length(timepoints)],\n                    w = weight)\n                }\n                corr[max.lag + 1] <- cor(data[i, ], data[j, ])\n                for(m in 1:max.lag){\n                    weight <- rbind(timepoints[(m + 1):length(timepoints)], timepoints[1:(length(timepoints) - m)])\n                    weight <- exp(-1/C * apply(weight, 2, function(x){(diff(x))^2}))\n                    corr[max.lag + m + 1] <- exp(-1/C * meansq.dist(timepoints[(m + 1):length(timepoints)],\n                    timepoints[1:(length(timepoints) - m)])) *\n                    wt.corr(data[j, 1:(length(timepoints) - m)],\n                    data[i, (m + 1):length(timepoints)],\n                    w = weight)\n                }\n                val <- -max.lag:max.lag\n                lags[j] <- val[which.max(corr)]\n                bcorr[j] <- max(corr)\n            }\n        }\n        lags <- lags[- i]\n        bcorr <- bcorr[- i]\n        shift[i] <- score(bcorr, lags)\n    }\n    return(shift)\n}\n\n# returns the a new dataset from the real dataset with NA's upon accounting the shifts\nprep.data <- function(data, lags){\n    stopifnot(dim(data)[1] == length(lags), is.vector(lags),\n    all(is.numeric(lags)))\n    new.data <- array(NA, dim(data))\n    for(i in 1:dim(data)[1]){\n        #given no lag\n        if(lags[i] == 0){new.data[i, ] <- data[i, ]}\n        #positive lag\n        else if(lags[i] > 0){\n            new.data[i, ] <- c(data[i, -(1:lags[i])], rep(NA, lags[i]))\n        }\n        #negative lag\n        else if(lags[i] < 0){\n            new.data[i, ] <- c(rep(NA, (-lags[i])), data[i, 1:(dim(data)[2] + lags[i])])\n        }\n        else{\n            print(\"There is an error in best lags!\")\n        }\n    }\n    return(new.data)\n}\n\n#takes two vectors with NA's of different length and align them\nweight.lag <- function(vector1, vector2){\n    if(length(vector1) < length(vector2)){\n        vector2 <- vector2[1:length(vector1)]\n    }\n    else{\n        vector1 <- vector1[1:length(vector2)]\n    }\n    return(as.matrix(rbind(vector1, vector2)))\n}\n\n#computes the lag penalized weighted correlation and returns it\ncomp.corr <- function(data, timepoints, C){\n    stopifnot(dim(data)[2] == length(timepoints), all(is.numeric(timepoints)),\n    is.numeric(C))\n    corr <- array(NA, c(dim(data)[1], dim(data)[1]))\n    for(j in 1:(dim(data)[1] - 1)){\n        for(i in (j + 1):dim(data)[1]){\n            pair <- rbind(data[i, ], data[j, ])\n            if(all(apply(pair, 2, function(x){all(!is.na(x))}))){\n                corr[i, j] <- cor(pair[1, ], pair[2, ])\n            }\n            else{\n                t1 <- timepoints[complete.cases(pair[1, ])]\n                t2 <- timepoints[complete.cases(pair[2, ])]\n                weight <- weight.lag(t1, t2)\n                comp <- complete.cases(t(pair))\n                weight <- weight[, 1:sum(comp)]\n                pair.full <- pair[, comp]\n                if(all(weight[1,] == weight[2,])){\n                    corr[i, j] <- cor(pair.full[1, ], pair.full[2, ])\n                }\n                else{\n                    weights <- exp(-1/C * apply(weight, 2, function(x){(diff(x))^2}))\n                    corr[i, j] <- exp(- 1 / C * meansq.dist(weight[1, ], weight[2, ])) *\n                    wt.corr(pair.full[1, ], pair.full[2, ], weights)\n                }\n            }\n        }\n    }\n    return(as.dist(corr))\n}\n\n\n#incorporates all the small function above and computes lag penalized weighted correlation for\n#   high penalty and low penalty and returns a list of correlation distance and best lags\ncorr.bestlag <- function(data, max.lag = 2, timepoints, C = NULL, penalty = NULL, k = 10, iter = 10){\n    stopifnot(dim(data)[2] == length(timepoints), max.lag <= length(timepoints) / 4 )\n    values <- findC(timepoints, max.lag, iter = iter)\n    if(penalty == \"high\" || is.numeric(C)){\n        lags <- best.lag(data, max.lag = max.lag, timepoints, C = values[1])\n        new.data <- prep.data(data, lags)\n        return(list(corr = comp.corr(new.data, timepoints, C = values[1]), lags = lags))\n    }\n    else if(penalty == \"low\"){\n        clustdiff <- rep(NA, length(values) - 1)\n        allcorr <- NULL\n        alllags <- NULL\n        for(i in 1:length(values)){\n            lags <- best.lag(data, max.lag = max.lag, timepoints, C = values[i])\n            new.data <- prep.data(data, lags)\n            result <- list(corr = comp.corr(new.data, timepoints, C = values[i]), lags = lags)\n            allcorr[[i]] <- result$corr\n            alllags[[i]] <- result$lags\n        }\n        for(j in 1:(length(values) - 1)){\n            clustdiff[j] <- (cutree(hclust(allcorr[[j + 1]]), k = k) - cutree(hclust(allcorr[[j]]), k = k)) ^ 2\n        }\n        return(list(corr = allcorr[[which.min(clustdiff) + 1]], lags = alllags[[which.min(clustdiff) + 1]]))\n    }\n}\n\n\n",
    "created" : 1502123757541.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4012873850",
    "id" : "FFFE9D1C",
    "lastKnownWriteTime" : 1501785487,
    "last_content_update" : 1501785487,
    "path" : "~/Desktop/LPC-R/R/lpc.R",
    "project_path" : "R/lpc.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}